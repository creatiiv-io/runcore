#!/bin/bash

# Ensure the script is run as the postgres user
if [ "$(id -u)" = '0' ]; then
  # Restart the script as the postgres user
  exec gosu postgres "$BASH_SOURCE" "$@"
fi

# Function to get conflict handling statements from PostgreSQL
function gen_conflict_clause() {
  local table=$1
  local update_columns=$2

  echo "
    SELECT 'ON CONFLICT ON CONSTRAINT ' || con.conname || ' DO UPDATE SET $update_columns'
    FROM pg_constraint con
    WHERE con.conrelid = '$table'::regclass
    AND con.contype IN ('p', 'u');
  " | PGHOST= PGHOSTADDR= psql -v QUIET=1 ON_ERROR_STOP=1 --username "$POSTGRES_USER" --no-password --no-psqlrc --dbname "$POSTGRES_DB" -t -A
}

function gen_where_clause() {
  local table="$1"
  local temp_table="$2"
  local headers="$3"
  local where=""

  # Split headers into an array based on colon delimiter
  IFS=':' read -r -a columns <<< "$headers"

  for column in "${columns[@]}"
  do
    if [ -z "$where" ]; then
      where="$table.$column = $temp_table.$column"
    else
      where="$where AND $table.$column = $temp_table.$column"
    fi
  done

  echo "$where"
}


# Function to process each file
function load_datafile() {
  local table="$1"
  local datafile="/datafiles/$1"
  local headers=$(head -n 1 "$datafile")
  local columns=${headers//:/, }
  local update_columns=$(echo $columns | sed 's/[^,]*/\0 = EXCLUDED.&/g')
  local temp_table="temp_data_${table//./_}"

  [ ! -f "$datafile" ] && echo 'datafile not found for table "'$table'".' && return

  echo 'updating table "'$table'" with new settings'

  # Get conflict handling statements for the table
  local conflict_clause=$(gen_conflict_clause "$table" "$update_columns")
  local where_clause=$(gen_where_clause "$table" $temp_table" "$headers")

  # Create temp file
  local tempfile=$(mktemp /tmp/$temp_table.import)

  # modify to add data to temp file
  sed -E '1 s/^/_:/; 2,$ s/^[^+-]/+&/; 2,$ s/^([+-])(.*)/\1:\2/' "$datafile" > "$tempfile"

  # Execute the SQL commands within a single transaction
  local dataload_sql="
    BEGIN;

    -- Create a temporary table with the same structure as the target table
    CREATE TEMP TABLE $temp_table AS SELECT * FROM $table LIMIT 0;

    -- Add operation column character to the table
    ALTER TABLE $temp_table
    ADD COLUMN _ char(1);

    -- Copy data from the CSV file into the temporary table
    \COPY $temp_table(_, $columns) FROM '$tempfile' DELIMITER ':' CSV HEADER;

    -- Insert data and handle conflicts if any exist
    INSERT INTO $table ($columns)
    SELECT $columns FROM $temp_table
    WHERE $temp_table._='+'
    $conflict_clause;

    -- Delete based on matching column values
    DELETE FROM $table
    USING $temp_table
    WHERE $temp_table._ = '-' AND $where_clause;

    -- Export updated data back to the original CSV file
    COPY (
        SELECT $columns
        FROM $table
    ) TO '$datafile' DELIMITER ':' CSV HEADER;

    -- Drop the temporary table to clean up
    DROP TABLE IF EXISTS $temp_table;

    COMMIT;
  "

  # echo "$conflict_statements"
  # echo "$dataload_sql"
  echo "$dataload_sql" | PGHOST= PGHOSTADDR= psql -v QUIET=1 ON_ERROR_STOP=1 --username "$POSTGRES_USER" --no-password --no-psqlrc --dbname "$POSTGRES_DB" -t -A
  [ "$?" = 0 ] && "DATA LOADED." || echo "Transaction failed... ROLLBACK."
}

[ -n "$1" ] && load_datafile $tablename && return

# Process each table in the correct order
for tablename in $(pg_tableorder); do
  # Check if the file exists in the datafiles
  if [ -f "/datafiles/$tablename" ]; then
    # load data from file
    load_datafile "$tablename"
  fi
done
